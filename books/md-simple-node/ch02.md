# 第二章 模块机制
JavaScript自诞生以来，曾经没有人拿它当做一门真正的编程语言，认为它不过是一种小的网页脚本而已，在Web1.0时代，这种脚本语言在网络中主要有两个作用广为流传，一个是表单校验，另一个是网页特效。另一方面，由于仓促地被创造出来，所以它自身的各种陷阱和缺点也被各种编程人员广为诟病。直到Web2.0时代，前端工程师利用它大大提升了网页上的用户体验。在这个过程中，B/C应用逐渐展现出比C/S应用优越的地方。至此，JavaScript才被广泛重视起来。

在Web2.0流行的过程中，各种前端库和框架被开发出来，它们最初用于兼容各个版本的浏览器，随后随着更多的用户需求在前端被实现，JavaScript也从表单校验跃迁到应用开发的级别上。在这个过程中，它大致经历了工具类库、组件库、前端框架、前端应用的变迁。

JavaScript的变迁：
1. 工具（浏览器兼容）
2. 组件（功能模块）
3. 框架（功能模块组织）
4. 应用（业务模块组织）

经历了长长的后天努力过程，JavaScript不断被类聚和抽象，以更好地组织业务逻辑。从另一个角度而言，它也道出了JavaScript先天就缺乏的一项功能：模块。

在其它高级语言中，Java有类文件，python有import机制，ruby有require，php有include和require。而JavaScript通过script标签引入代码的方式显得杂乱无章，语言自身毫无组织和约束能力。人们不得不用命名空间等方式人为地约束代码，以求达到安全和易用的目的。

但是看起来凌乱的JavaScript编程现状并不代表着社区没有进步，JavaScript的本地化编程之路一直在探索中。在Node出现之前，服务器端JavaScript基本没有市场，与欣欣向荣的前端JavaScript应用相比，Rhino等后端JavaScript运行环境基本只是用于小工具，但是经历十多年的发展后，社区也为JavaScript制定了相应的规范，其中CommonJS规范的提出具有里程碑意义。

## 2.1 CommonJS规范
CommonJS规范为JavaScript制定了一个美好的愿景：希望JavaScript能够在任何地方运行。

### 2.1.1 CommonJS的出发点
在JavaScript的发展历程中，JavaScript主要在浏览器前端发光发热。由于官方规范（ECMAScript）规范化的时间较早，规范涵盖的范畴非常小。这些规范中包含词法、类型、上下文、表达式、声明、方法、对象等语言的基本要素。在实际应用中，JavaScript的表现能力取决于宿主环境中的API支持程度。在Web1.0时代，只有对DOM、BOM等基本的支持。随着web2.0的推进，HTML5崭露头角，它将web网页带进web应用的时代，在浏览器中出现了更多、更强大的API供JavaScript调用，这得感谢w3c组织对HTML5规范的推进以及各大浏览器厂商对规范的大力支持。但是，web在发展，浏览器中出现了更多的标准API，这些过程发生在前端，后端JavaScript的规范却远远落后。对于JavaScript自身而言，它的规范依然是薄弱的，还有以下缺陷：
- 没有模块系统
- 标准库较少。ECMAScript仅定义了部分核心库，对于文件系统、I/O流等常见需求却没有标准的API。就HTML5的发展状况而言，w3c标准化在一定意义上是在推进这个过程，但是它仅限于浏览器端。
- 没有标准接口。在JavaScript中，几乎没有定义过如Web服务器或者数据库之类的标准统一接口。
- 缺乏包管理系统。这导致JavaScript应用中基本没有自动加载和安装依赖的能力。

CommonJS规范的提出，主要是为了弥补当时JavaScript没有标准的缺陷，以达到像Python、Ruby和Java具备开发大型应用的基础能力，而不是停留在小脚本程序的阶段。他们期望那些用CommonJS API写出的应用可以具备跨宿主环境执行的能力，这样不仅可以利用JavaScript开发富客户端应用，而且还可以编写以下应用：
- 服务端JavaScript应用程序
- 命令行工具
- 桌面图形界面应用程序
- 混合应用（Titanium和Adobe AIR等形式的应用）

如今，CommonJS中的大部分规范虽然依旧是草案，但是已经初显成效，为JavaScript开发大型应用程序指明了一条非常棒的道路。目前，它依旧在成长中，这些规范涵盖了模块、二进制、Buffer、字符集编码、I/O流、进程环境、文件系统、套接字、单元测试、Web服务器网关接口、包管理等。

理论和实践总是相互影响和促进的，Node能以一种比较成熟的姿态出现，离不开CommonJS规范的影响。在服务器端，CommonJS能以一种寻常的姿态写进各个公司的项目代码中，离不开Node优异的表现，Node的优良表现离不开规范最初优秀的设计，规范又因Node的推广而得以普及。

Node借鉴CommonJS的模块规范实现了一套非常易用的模块系统，npm对包规范的完好支持使得Node应用在开发过程中事半功倍。

### 2.1.2 CommonJS的模块规范
CommonJS对模块的定义十分简单，主要分为模块引用、模块定义和模块标识3个部分。

**1.模块引用**
模块引用的示例代码如下：
```js
var math = require('math');
```
在CommonJS规范中，存在require()方法，这个方法接受模块标识，以此引入一个模块的API到当前上下文中。

**2.模块定义**
在模块中，上下文提供require()方法来引入外部模块。对应引入的功能，上下文提供了exports对象用于导出当前模块的方法或者变量，并且它是唯一导出的出口。在模块中，还存在一个module对象，它代表模块本身，而exports是module的属性。在Node中，一个文件就是一个模块，将方法挂载在exports对象上作为属性即可定义导出的方式：
```js
// aa.js
exports.add = function(a, b) {

};

// bb,js 另一个文件
var aa = require('./aa');
aa.add(3,1);
```

**3.模块标识**
模块标识其实就是传递给reuqire()方法的参数，它必须是符合小驼峰命名的字符串，或者以`.`、`..`开头的相对路径，或者是绝对路径。可以忽略文件后缀。

模块的定义十分简单，接口也十分简洁。它的意义在于将类聚的方法和变量等限定在私有的作用域中，同时支持引入和导出功能以顺畅地连接上下游依赖。每个模块具有独立的空间，它们互不干扰，在引用时也显得干净利落。CommonJS构建的这套模块导出和引入机制使得用户完全不必考虑变量污染。命名空间等方案与之相比相形见绌。

## 2.2 Node的模块实现
Node在实现中并非完全按照规范实现，而是对模块规范进行了一定的取舍，同时也增加了一些自身需要的特性。尽管规范中exports、require和module听起来十分简单，但是Node在实现它们的过程中究竟经历了什么，这个过程需要知晓。

在Node中引入模块，需要经历如下3个步骤：
1. 路径分析
2. 文件定位
3. 编译执行

在Node中，模块分为两类：一类是Node提供的模块，称为核心模块；另一类是用户编写的模块，称为文件模块。
- 核心模块部分在Node源代码的编译过程中，编译进了二进制执行文件。在Node进程启动时，部分核心模块就被直接加载进内存中，所以这部分核心模块引入时，文件定位和编译执行这两个步骤可以省略掉，并且在路径分析中优先判断，所以它的加载速度是最快的。
- 文件模块则是在运行时动态加载，需要完整的路径分析、文件定位、编译执行三个过程，速度比核心模块慢。

### 2.2.1 优先从缓存加载
展开介绍路径分析和文件定位之前，我们需要知晓的一点是，与前端浏览器会缓存静态脚本文件以提高性能一样，Node对引入过的模块都会进行缓存，以减少二次引入时的开销。不同的地方在于，浏览器仅仅缓存文件，而Node缓存的是编译和执行之后的对象。

不论是核心模块还是文件模块，require()方法对相同模块的二次加载都一律采用缓存优先的方式，这是第一优先级的。不同之处在于核心模块的缓存检查先于文件模块的缓存检查。

### 2.2.2 路径分析和文件定位
因为标识符有几种形式，对于不同的标识符，模块的查找和定位有不同程度上的差异。

**1.模块标识符分析：**
前面提到过，require()方法接收一个标识符作为参数。在Node实现中，正是基于这样一个标识符进行模块查找的。模块标识符在Node中主要分为以下几类：
- 核心模块，如http，fs，path等
- 以`.`或`..`开始的相对路径文件模块
- 绝对路径文件模块
- 非路径形式的文件模块，如自定义的connect模块

核心模块：
核心模块的优先级仅次于缓存加载，它在Node的源代码编译过程中已经编译为二进制代码，其加载过程最快。如果试图加载一个与核心模块标识符相同的自定义模块，那是不会成功的。如果自己编写了一个http用户模块，想要加载成功，必须选择一个不同的标识符或者换用路径的方式。

路径形式的文件模块：
在分析相对路径和绝对路径的文件模块时，require()方法会将路径转为真实路径，并以真实路径作为索引，将编译执行后的结果存放到缓存中，以便二次加载时更快。由于文件模块给Node指明了确切的文件位置，所以在查找过程中可以节约大量时间，其加载速度慢于核心模块。

自定义模块：
自定义模块指的是非核心模块，也不是路径形式的文件模块。它是一种特殊的文件模块，可能是一个文件或者包的形式。这类模块的查找是最费时的，是所有方式中最慢的一种。在介绍自定义模块的查找方式之前，需要先介绍一下模块路径这个概念。

模块路径是Node在定位文件模块的具体文件时制定的查找策略，具体表现为一个路径组成的数组。关于这个路径的生成规则，我们可以手动尝试一番。
1. 创建abc.js文件，其内容为`console.log(module.paths)`
2. 将文件放到任意一个目录中然后执行abc.js
```js
// 在Linux上，你可能得到这样的一个数组输出
[ '/home/brenner/aa/node_modules',
  '/home/brenner/node_modules',
  '/home/node_modules',
  '/node_modules' ]

// 在Windows，也许是这样
[ 'D:\\aa\\bb\\node_modules',
  'D:\\aa\\node_modules',
  'D:\\node_modules' ]
```

可以看出，模块路径的生成规则如下：
1. 当前文件目录下的node_modules目录
2. 父目录下的node_modules目录
3. 父目录下的父目录下的node_modules目录
4. 沿路径向上逐级递归，直到根目录下的node_modules目录

它的生成方式与JavaScript的原型链或作用域链的查找方式十分类似。在加载的过程中，Node会逐个尝试模块路径中的路径，直到找到目标文件为止。可以看出，当前文件的路径越深，模块查找耗时会越多，这就是自定义模块的加载速度是最慢的原因。

**2.文件定位：**
从缓存加载的优化策略使得二次引入时不需要路径分析、文件定位和编译执行的过程，大大提高了再次加载模块时的效率。但是在文件定位过程中，还有一些细节需要注意，这主要包括文件扩展名的分析、目录和包的处理。

文件扩展名分析：
require()方法在分析标识符的过程中，会出现标识符中不包含文件扩展名的情况。CommonJS模块规范也允许在标识符中不包含文件扩展名，这种情况下，Node会按js、json、node的次序补足扩展名，依次尝试。

在尝试的过程中，需要调用fs模块同步阻塞式地判断文件是否存在。因为Node是单线程的，所以这里是一个会引起性能问题的地方。小诀窍是：如果是node和json的文件后缀名，在传递给require()的标识符中带上扩展名，会加快一点速度。另一个诀窍是：同步配合缓存，可以大幅度缓解Node单线程中阻塞式调用的缺陷。

目录分析和包：
在分析标识符的过程中，require()通过分析文件扩展名之后，可能没有查找到对应文件，但却得到一个目录，这在引入自定义模块和逐个模块路径进行查找时经常会出现，此时Node会将目录当做一个包来处理。

在这个过程中，Node对CommonJS包规范进行了一定程度的支持。首先，Node在当前目录下查找package.json（CommonJS包规范定义的包描述文件），通过`JSON.parse()`解析出包描述对象，从中取出main属性指定的文件名进行定位。如果文件名缺少扩展名，将会进入扩展名分析的步骤。

如果main属性指定的文件名错误，或者压根没有package.json文件，Node会将index当做默认文件名，然后依次查找index.js、index.json、index.node。

如果在目录分析的过程中，没有定位成功任何文件，则自定义模块进入下一个模块路径进行查找。如果模块路径数组都被遍历完毕，依然没有查找到目标文件，则会抛出查找失败的异常。

### 2.2.3 模块编译
