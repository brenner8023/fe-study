# 第二章 模块机制
JavaScript自诞生以来，曾经没有人拿它当做一门真正的编程语言，认为它不过是一种小的网页脚本而已，在Web1.0时代，这种脚本语言在网络中主要有两个作用广为流传，一个是表单校验，另一个是网页特效。另一方面，由于仓促地被创造出来，所以它自身的各种陷阱和缺点也被各种编程人员广为诟病。直到Web2.0时代，前端工程师利用它大大提升了网页上的用户体验。在这个过程中，B/C应用逐渐展现出比C/S应用优越的地方。至此，JavaScript才被广泛重视起来。

在Web2.0流行的过程中，各种前端库和框架被开发出来，它们最初用于兼容各个版本的浏览器，随后随着更多的用户需求在前端被实现，JavaScript也从表单校验跃迁到应用开发的级别上。在这个过程中，它大致经历了工具类库、组件库、前端框架、前端应用的变迁。

JavaScript的变迁：
1. 工具（浏览器兼容）
2. 组件（功能模块）
3. 框架（功能模块组织）
4. 应用（业务模块组织）

经历了长长的后天努力过程，JavaScript不断被类聚和抽象，以更好地组织业务逻辑。从另一个角度而言，它也道出了JavaScript先天就缺乏的一项功能：模块。

在其它高级语言中，Java有类文件，python有import机制，ruby有require，php有include和require。而JavaScript通过script标签引入代码的方式显得杂乱无章，语言自身毫无组织和约束能力。人们不得不用命名空间等方式人为地约束代码，以求达到安全和易用的目的。

但是看起来凌乱的JavaScript编程现状并不代表着社区没有进步，JavaScript的本地化编程之路一直在探索中。在Node出现之前，服务器端JavaScript基本没有市场，与欣欣向荣的前端JavaScript应用相比，Rhino等后端JavaScript运行环境基本只是用于小工具，但是经历十多年的发展后，社区也为JavaScript制定了相应的规范，其中CommonJS规范的提出具有里程碑意义。

## 2.1 CommonJS规范
CommonJS规范为JavaScript制定了一个美好的愿景：希望JavaScript能够在任何地方运行。

### 2.1.1 CommonJS的出发点
在JavaScript的发展历程中，JavaScript主要在浏览器前端发光发热。由于官方规范（ECMAScript）规范化的时间较早，规范涵盖的范畴非常小。这些规范中包含词法、类型、上下文、表达式、声明、方法、对象等语言的基本要素。在实际应用中，JavaScript的表现能力取决于宿主环境中的API支持程度。在Web1.0时代，只有对DOM、BOM等基本的支持。随着web2.0的推进，HTML5崭露头角，它将web网页带进web应用的时代，在浏览器中出现了更多、更强大的API供JavaScript调用，这得感谢w3c组织对HTML5规范的推进以及各大浏览器厂商对规范的大力支持。但是，web在发展，浏览器中出现了更多的标准API，这些过程发生在前端，后端JavaScript的规范却远远落后。对于JavaScript自身而言，它的规范依然是薄弱的，还有以下缺陷：
- 没有模块系统
- 标准库较少。ECMAScript仅定义了部分核心库，对于文件系统、I/O流等常见需求却没有标准的API。就HTML5的发展状况而言，w3c标准化在一定意义上是在推进这个过程，但是它仅限于浏览器端。
- 没有标准接口。在JavaScript中，几乎没有定义过如Web服务器或者数据库之类的标准统一接口。
- 缺乏包管理系统。这导致JavaScript应用中基本没有自动加载和安装依赖的能力。

CommonJS规范的提出，主要是为了弥补当时JavaScript没有标准的缺陷，以达到像Python、Ruby和Java具备开发大型应用的基础能力，而不是停留在小脚本程序的阶段。他们期望那些用CommonJS API写出的应用可以具备跨宿主环境执行的能力，这样不仅可以利用JavaScript开发富客户端应用，而且还可以编写以下应用：
- 服务端JavaScript应用程序
- 命令行工具
- 桌面图形界面应用程序
- 混合应用（Titanium和Adobe AIR等形式的应用）

如今，CommonJS中的大部分规范虽然依旧是草案，但是已经初显成效，为JavaScript开发大型应用程序指明了一条非常棒的道路。目前，它依旧在成长中，这些规范涵盖了模块、二进制、Buffer、字符集编码、I/O流、进程环境、文件系统、套接字、单元测试、Web服务器网关接口、包管理等。

理论和实践总是相互影响和促进的，Node能以一种比较成熟的姿态出现，离不开CommonJS规范的影响。在服务器端，CommonJS能以一种寻常的姿态写进各个公司的项目代码中，离不开Node优异的表现，Node的优良表现离不开规范最初优秀的设计，规范又因Node的推广而得以普及。

Node借鉴CommonJS的模块规范实现了一套非常易用的模块系统，npm对包规范的完好支持使得Node应用在开发过程中事半功倍。

### 2.1.2 CommonJS的模块规范
CommonJS对模块的定义十分简单，主要分为模块引用、模块定义和模块标识3个部分。

**1.模块引用**
模块引用的示例代码如下：
```js
var math = require('math');
```
在CommonJS规范中，存在require()方法，这个方法接受模块标识，以此引入一个模块的API到当前上下文中。

**2.模块定义**
在模块中，上下文提供require()方法来引入外部模块。对应引入的功能，上下文提供了exports对象用于导出当前模块的方法或者变量，并且它是唯一导出的出口。在模块中，还存在一个module对象，它代表模块本身，而exports是module的属性。在Node中，一个文件就是一个模块，将方法挂载在exports对象上作为属性即可定义导出的方式：
```js
// aa.js
exports.add = function(a, b) {

};

// bb,js 另一个文件
var aa = require('./aa');
aa.add(3,1);
```

**3.模块标识**
模块标识其实就是传递给reuqire()方法的参数，它必须是符合小驼峰命名的字符串，或者以`.`、`..`开头的相对路径，或者是绝对路径。可以忽略文件后缀。

模块的定义十分简单，接口也十分简洁。它的意义在于将类聚的方法和变量等限定在私有的作用域中，同时支持引入和导出功能以顺畅地连接上下游依赖。每个模块具有独立的空间，它们互不干扰，在引用时也显得干净利落。CommonJS构建的这套模块导出和引入机制使得用户完全不必考虑变量污染。命名空间等方案与之相比相形见绌。

## 2.2 Node的模块实现
Node在实现中并非完全按照规范实现，而是对模块规范进行了一定的取舍，同时也增加了一些自身需要的特性。尽管规范中exports、require和module听起来十分简单，但是Node在实现它们的过程中究竟经历了什么，这个过程需要知晓。

在Node中引入模块，需要经历如下3个步骤：
1. 路径分析
2. 文件定位
3. 编译执行

在Node中，模块分为两类：一类是Node提供的模块，称为核心模块；另一类是用户编写的模块，称为文件模块。
- 核心模块部分在Node源代码的编译过程中，编译进了二进制执行文件。在Node进程启动时，部分核心模块就被直接加载进内存中，所以这部分核心模块引入时，文件定位和编译执行这两个步骤可以省略掉，并且在路径分析中优先判断，所以它的加载速度是最快的。
- 文件模块则是在运行时动态加载，需要完整的路径分析、文件定位、编译执行三个过程，速度比核心模块慢。

### 2.2.1 优先从缓存加载
展开介绍路径分析和文件定位之前，我们需要知晓的一点是，与前端浏览器会缓存静态脚本文件以提高性能一样，Node对引入过的模块都会进行缓存，以减少二次引入时的开销。不同的地方在于，浏览器仅仅缓存文件，而Node缓存的是编译和执行之后的对象。

不论是核心模块还是文件模块，require()方法对相同模块的二次加载都一律采用缓存优先的方式，这是第一优先级的。不同之处在于核心模块的缓存检查先于文件模块的缓存检查。

### 2.2.2 路径分析和文件定位
因为标识符有几种形式，对于不同的标识符，模块的查找和定位有不同程度上的差异。

**1.模块标识符分析：**
前面提到过，require()方法接收一个标识符作为参数。在Node实现中，正是基于这样一个标识符进行模块查找的。模块标识符在Node中主要分为以下几类：
- 核心模块，如http，fs，path等
- 以`.`或`..`开始的相对路径文件模块
- 绝对路径文件模块
- 非路径形式的文件模块，如自定义的connect模块

核心模块：
核心模块的优先级仅次于缓存加载，它在Node的源代码编译过程中已经编译为二进制代码，其加载过程最快。如果试图加载一个与核心模块标识符相同的自定义模块，那是不会成功的。如果自己编写了一个http用户模块，想要加载成功，必须选择一个不同的标识符或者换用路径的方式。

路径形式的文件模块：
在分析相对路径和绝对路径的文件模块时，require()方法会将路径转为真实路径，并以真实路径作为索引，将编译执行后的结果存放到缓存中，以便二次加载时更快。由于文件模块给Node指明了确切的文件位置，所以在查找过程中可以节约大量时间，其加载速度慢于核心模块。

自定义模块：
自定义模块指的是非核心模块，也不是路径形式的文件模块。它是一种特殊的文件模块，可能是一个文件或者包的形式。这类模块的查找是最费时的，是所有方式中最慢的一种。在介绍自定义模块的查找方式之前，需要先介绍一下模块路径这个概念。

模块路径是Node在定位文件模块的具体文件时制定的查找策略，具体表现为一个路径组成的数组。关于这个路径的生成规则，我们可以手动尝试一番。
1. 创建abc.js文件，其内容为`console.log(module.paths)`
2. 将文件放到任意一个目录中然后执行abc.js
```js
// 在Linux上，你可能得到这样的一个数组输出
[ '/home/brenner/aa/node_modules',
  '/home/brenner/node_modules',
  '/home/node_modules',
  '/node_modules' ]

// 在Windows，也许是这样
[ 'D:\\aa\\bb\\node_modules',
  'D:\\aa\\node_modules',
  'D:\\node_modules' ]
```

可以看出，模块路径的生成规则如下：
1. 当前文件目录下的node_modules目录
2. 父目录下的node_modules目录
3. 父目录下的父目录下的node_modules目录
4. 沿路径向上逐级递归，直到根目录下的node_modules目录

它的生成方式与JavaScript的原型链或作用域链的查找方式十分类似。在加载的过程中，Node会逐个尝试模块路径中的路径，直到找到目标文件为止。可以看出，当前文件的路径越深，模块查找耗时会越多，这就是自定义模块的加载速度是最慢的原因。

**2.文件定位：**
从缓存加载的优化策略使得二次引入时不需要路径分析、文件定位和编译执行的过程，大大提高了再次加载模块时的效率。但是在文件定位过程中，还有一些细节需要注意，这主要包括文件扩展名的分析、目录和包的处理。

文件扩展名分析：
require()方法在分析标识符的过程中，会出现标识符中不包含文件扩展名的情况。CommonJS模块规范也允许在标识符中不包含文件扩展名，这种情况下，Node会按js、json、node的次序补足扩展名，依次尝试。

在尝试的过程中，需要调用fs模块同步阻塞式地判断文件是否存在。因为Node是单线程的，所以这里是一个会引起性能问题的地方。小诀窍是：如果是node和json的文件后缀名，在传递给require()的标识符中带上扩展名，会加快一点速度。另一个诀窍是：同步配合缓存，可以大幅度缓解Node单线程中阻塞式调用的缺陷。

目录分析和包：
在分析标识符的过程中，require()通过分析文件扩展名之后，可能没有查找到对应文件，但却得到一个目录，这在引入自定义模块和逐个模块路径进行查找时经常会出现，此时Node会将目录当做一个包来处理。

在这个过程中，Node对CommonJS包规范进行了一定程度的支持。首先，Node在当前目录下查找package.json（CommonJS包规范定义的包描述文件），通过`JSON.parse()`解析出包描述对象，从中取出main属性指定的文件名进行定位。如果文件名缺少扩展名，将会进入扩展名分析的步骤。

如果main属性指定的文件名错误，或者压根没有package.json文件，Node会将index当做默认文件名，然后依次查找index.js、index.json、index.node。

如果在目录分析的过程中，没有定位成功任何文件，则自定义模块进入下一个模块路径进行查找。如果模块路径数组都被遍历完毕，依然没有查找到目标文件，则会抛出查找失败的异常。

### 2.2.3 模块编译
在Node中，每个文件模块都是一个对象，它的定义如下：
```js
function Module(id, parent) {
    this.id = id;
    this.exports = {};
    this.parent = parent;
    if(parent && parent.children) {
        parent.children.push(this);
    }
    this.filename = null;
    this.loaded = false;
    this.children = [];
}
```
编译和执行是引入文件模块的最后一个阶段。定位到具体的文件后，Node会新建一个模块对象，然后根据路径载入并编译。对于不同的文件扩展名，其载入方法也有所不同，具体如下所示：
- js文件：通过fs模块同步读取文件后编译执行
- json文件：通过fs模块同步读取文件后，用`JSON.parse()`解析返回结果。
- node文件：这是用C/C++编写的扩展文件，通过dlopen()方法加载最后编译生成的文件
- 其余扩展名文件：都会被当作js文件载入

每一个编译成功的模块都会将其文件路径作为索引缓存在`Module._cache`对象上，以提高二次引入的性能。

根据不同的文件扩展名，Node会调用不同的读取方式，如json文件的调用如下：
```js
Module._extensions['.json'] = function(module, filename) {
    var content = NativeModule.require('fs').readFileSync(filename, 'utf8');
    try {
        module.exports = JSON.parse(stripBOM(content));
    } catch(err) {
        err.message = filename + ':' + err.message;
        throw err;
    }
};
```
其中，`Module._extensions`会被赋值给require()的extensions属性，所以通过在代码中访问require.extensions可以知道系统中已有的扩展加载方式。编写如下代码测试：
```js
console.log(require.extensions);

// ==> { '.js': [Function], '.json': [Function], '.node': [Function] }
```
如果想对自定义的扩展名进行特殊的加载，可以通过类似`require.extensions['.ext']`的方式实现。早期的CoffeeScript文件就是通过添加`require.extensions['.coffee']`扩展的方式来实现加载的。但是从v0.10.6版本开始，官方不鼓励通过这种方式来进行自定义扩展名的加载，而是期望先将其它语言或文件编译成JavaScript文件后再加载，这样做的好处在于不将繁琐的编译加载等过程引入Node的执行过程中。

在确定文件的扩展名之后，Node将调用具体的编译方式来将文件执行后返回给调用者。

**1.JavaScript模块的编译：**
回到CommonJS模块规范，我们知道每个模块文件中存在着require、exports、module这3个变量，但是它们在模块文件中并没有定义，那么它们从何而来呢？甚至在Node的API文档中，我们知道每个模块中还有__filename、__dirname这两个变量的存在，又是从何而来呢？

事实上，在编译的过程中，Node对获取的JavaScript文件内容进行了头尾包装。在头部添加了`(function(exports, require, module, __dirname, __filename){`，在尾部添加了`});`。一个正常的JavaScript文件会被包装成如下的样子：
```js
(function(exports, require, module, __filename, __dirname){
    var math = require('math');
    exports.area = function() {};
});
```
这样每个模块文件之间都进行了作用域隔离。包装之后的代码会通过vm原生模块的runInThisContext()方法执行（类似eval，只是具有明确上下文，不污染全局），返回一个具体的function对象。最后，将当前模块对象的exports属性、require()方法、module模块对象自身，以及在文件定位中得到的完整文件路径和文件目录作为参数传递给这个function执行。

这就是这些变量并没有定义在每个模块文件中却存在的原因。在执行之后，模块的exports属性被返回给了调用方。exports属性上的任何方法和属性都可以被外部调用到，但是模块中的其余变量或属性则不可直接被调用。

至此，require、exports、module的流程已经完整，这就是Node对CommonJS模块规范的实现。此外，许多初学者都曾经纠结过为何存在exports的情况下，还存在module.exports。理想情况下，只要赋值给exports即可：
```js
exports = function() {}
```
但是这样做通常会得到一个失败的结果，其原因在于，exports对象是通过形参的方式传入的，直接赋值形参会改变形参的引用，但并不能改变作用域外的值。因此，有了一个迂回的方案，赋值给module.exports对象

**2.c/c++模块的编译：**
Node调用process.dlopen()方法进行加载和执行。在Node的架构下，dlopen()方法在Windows和Linux平台下分别有不同的实现，通过libuv兼容层进行了封装。

实际上，node文件并不需要编译，因为它是编写c/c++代码之后编译生成的，所以这里只有加载和执行的过程。在执行的过程中，模块的exports对象与node文件产生联系，然后返回给调用者。c/c++模块给Node使用者带来的优势主要是执行效率方面的，劣势则是c/c++文件的编写门槛比JavaScript高。

**3.json文件的编译：**
Node利用fs模块同步读取json文件的内容之后，调用JSON.parse()方法得到对象，然后将它赋给模块对象的exports，以供外部调用。JSON文件在用作项目的配置文件时比较有用。如果你定义了一个JSON文件作为配置，那就不必调用fs模块去异步读取和解析，直接调用require()引入即可，并且二次引入也没有性能影响。

## 2.3 核心模块
核心模块其实分为c/c++编写的和JavaScript编写的两部分，其中c/c++文件放在src目录下，JavaScript文件存放在lib目录下。

### 2.3.1 JavaScript核心模块的编译过程
在编译所有c/c++文件之前，编译程序需要将所有的JavaScript模块文件编译为c/c++代码。
**1.转存为c/c++代码：**
Node采用了v8附带的js2c.py工具，将所有内置的JavaScript代码转换成c++里的数组，生成node_natives.h头文件。在这个过程中，JavaScript代码以字符串的形式存储在node命名空间中，是不可直接执行的。在启动Node进程时，JavaScript代码直接加载进内存中。在加载的过程中，JavaScript核心模块经历标识符分析后直接定位到内存中，比普通的文件模块要从硬盘中一处一处查找来快得多。

**2.编译JavaScript核心模块：**
lib目录下的所有模块文件也没有定义require、module等这些变量。在引入JavaScript核心模块的过程中，也经历了头尾包装的过程，然后才执行和导出了exports对象。

### 2.3.2 c/c++核心模块的编译过程
在核心模块中，有一些模块全部由c/c++编写，有些模块则由c/c++完成核心部分，其它部分则由JavaScript实现包装或向外导出，以满足性能需求。后面这种c++模块主内完成核心，JavaScript主外实现封装的模式是Node能够提高性能的常见方式。Node的这种复合模式可以在开发速度和性能之间找到平衡点。

## 2.5 模块调用栈
c/c++内建模块属于最底层的模块，它属于核心模块，主要提供API给JavaScript核心模块和第三方JavaScript文件模块调用。JavaScript核心模块主要扮演的职责有两类：一类是作为c/c++内建模块的封装层和桥接层，供文件模块调用；一类是纯粹的功能模块，它不需要和底层打交道，但是十分重要。

## 2.6 包与npm
在介绍npm之前，不得不提起CommonJS的包规范。JavaScript不像Java或者其它语言那样，具有模块和包结构。Node对模块规范的实现，一定程度上解决了变量依赖、依赖关系等代码组织性问题。包的出现，则是在模块的基础上进一步组织JavaScript代码。CommonJS的包规范的定义其实也十分简单，它由包结构和包描述文件两个部分组成，前者用于组织包中的各种文件，后者则用于描述包的相关信息，以供外部读取分析。

### 2.6.1 包结构
包实际上是一个存档文件，即一个目录直接打包为zip或tar.gz格式的文件，安装后解压还原为目录。完全符合CommonJS规范的包目录应该包含如下这些文件：
- package.json：包描述文件
- bin：用于存放可执行二进制文件的目录
- lib：用于存放JavaScript代码的目录
- doc：用于存放文档的目录
- test：用于存放单元测试用例的代码

### 2.6.2 包描述文件与npm
包描述文件用于表达非代码相关的信息，它是一个json格式的文件，位于包的根目录下，而npm的所有行为都与包描述文件的字段息息相关。包规范的定义可以帮助Node解决依赖包安装的问题，而npm正是基于该规范进行了实现。在包描述文件的规范中，npm实际需要的字段主要有以下几个：
- name：包名，需要由小写的字母和数字组成，可以包含下划线和短横线和实心点，包名必须是唯一，避免对外公布产生命名冲突。
- version：版本号，通常是major.minor.revision格式
- description：包简介
- keywords：关键词数组，npm中主要用来做分类搜索
- repositories：托管源代码的位置列表，表明可以通过哪些方式和地址访问包的源代码
- dependencies：使用当前包所需要依赖的包的列表。
- author：包作者
- bin：配置好bin字段后，通过`npm i package_name`可以将脚本添加到执行路径中，之后可以在命令行中直接执行
- main：require()方法在引入包时，会优先检查这个字段，并将其作为包中其余模块的入口。如果不存在这个字段，require()方法会查找包目录下的index.js、index.node、index.json文件作为默认入口
- devDependencies：一些模块只在开发时需要依赖

### 2.6.3 npm常用功能
CommonJS包规范是理论，npm是其中的一种实现。npm之于Node，相当于gem之于Ruby、pear之于PHP。对于Node而言，npm帮助完成了第三方模块的发布、安装和依赖等。借助npm，Node与第三方模块之间形成了很好的一个生态系统。

1. 查看帮助：
在安装Node之后，执行`npm -v`可以查看当前npm的版本，如果不熟悉npm的命令，可以直接执行`npm`查看帮助引导说明。`npm help <command>`可以查看具体的命令说明。

2. 安装依赖包：
安装依赖包是npm最常见的用法，它的执行语句是`npm install <包名>`，比如`npm install express`。执行该命令后，npm会在当前目录下创建node_mudles目录，然后在nodule_modules目录下创建express目录，接着将包解压到这个目录下。安装好依赖包后，直接在代码中调用`require('express');`即可引入该包。

全局模式安装：
如果包中含有命令行工具，那么需要执行`npm install <包名> -g`进行全局模式安装。需要注意的是，全局模式并不是将一个模块包安装为一个全局包的意思，它并不意味着可以从任何地方通过require()方法来引用它。安装为全局模式实际上是将一个包安装为全局可用的可执行命令。它根据包描述文件中的bin字段配置，将实际脚本链接到与Node可执行文件相同的路径。

从本地安装：
对于一些没有发布到npm上的包，或是因为网络原因导致无法直接安装的包，可以通过将包下载到本地，然后使用本地安装方式。本地安装只需为npm指明package.json文件所在的位置即可：它可以是一个包含package.json的存档文件，也可以是一个url地址，也可以是一个目录下有package.json文件的文件夹。
```shell
npm i <tarball file>
npm i <tarball url>
npm i <folder>
```

从非官方源安装：
如果不能通过官方源安装，可以通过镜像源安装。在执行命令时，添加`--registry=https://www.baidu.com`即可，`npm config set registry https://www.baidu.com`可以指定默认源

3. npm钩子命令：
package.json中scripts字段的提出就是让包在安装或者卸载等过程中提供钩子机制，示例如下：
```json
"scripts": {
    "preinstall": "preinstall.js",
    "install": "install.js",
    "uninstall": "uninstall.js",
    "test": "test.js"
}
```
在以上字段中执行`npm i <package>`时，preinstall指向的脚本将会被加载执行，然后install指向的脚本将会被执行。

4. 发布包：
- 编写模块
- 初始化包描述文件，使用`npm init`会帮助你生成package.json文件
- 使用`npm adduser`注册包仓库账号
- 使用`npm publish .`上传包，在这个过程中npm会将文件夹打包为一个存档文件，然后上传
- 使用`npm i <package>`来安装体验和测试自己的包
- 管理包权限，通常，一个包只有一个人拥有权限进行发布，可以使用`npm owner`帮助你管理包的所有者
- 使用`npm ls`可以帮你分析出当前路径下能够通过模块路径找到的所有包，并生成包的依赖树

### 2.6.4 局域npm
在企业的内部应用中使用npm与开源社区中使用有一定的差别。企业的限制在于，一方面需要享受到模块开发带来的低耦合和项目组织上的好处，另一方面却要考虑到模块保密性的问题。所以，通过npm共享和发布存在潜在的风险。

为了能同时享受到npm上众多的包，同时对自己的包进行保密和限制，现有的解决方案就是企业搭建自己的npm仓库。npm自身是开源，所以可以通过源代码搭建自己的仓库。

### 2.6.5 npm潜在问题
作为服务于模块和包的工具，npm十分便捷。它实质上已经是一个包共享平台，所有人都可以贡献模块并将其打包分享到这个平台上，也可以在许可证的允许下免费使用它们。npm潜在的问题在于，在npm平台上，每个人都可以分享包到平台上，鉴于开发人员水平不一，上面的包的质量也良莠不齐。另一个问题是，包的代码如果运行在服务器端（Node），需要考虑安全问题。

对于包的使用者而言，包的质量和安全问题需要作为是否采纳模块的一个判断条件。npm模块首页上的依赖榜可以说明模块的质量和可靠性。第二个可以考察质量的地方是GitHub，npm中的大多数包都是通过github托管的。

在安全问题上，经过模块质量的考查之后，应该可以去掉一大半候选包。基于使用者大多是JavaScript工程师，难点其实存在于第三方c/c++扩展模块，这类模块建议在企业的安全部门检查之后方可允许使用。
