## 多进程
- Browser进程（浏览器的主进程）
- 第三方插件进程
- GPU进程（浏览器渲染进程，和前端密切相关）

GPU进程：
- GUI渲染线程
- JS引擎线程
- 事件触发线程（和EventLoop密切相关）
- 定时触发器线程
- 异步HTTP请求线程

GUI渲染线程与JS引擎线程互斥，为了防止DOM渲染的不一致性，其中一个线程执行时，另一个线程就会被挂起。

浏览器页面初次渲染完毕后，同步任务在JS引擎线程（主线程）上执行，形成**执行栈**。

JS引擎线程（主线程）之外，事件触发线程管理着一个**任务队列**，只要异步任务有了运行结果，就在任务队列中放置一个事件。

执行栈中的同步任务执行完毕，系统就会读取任务队列，如果有异步任务需要执行，将其添加到主线程的执行栈，执行相应的异步任务。

执行上下文：当调用一个方法的时候，js会生成一个与这个方法对应的执行上下文。这个执行上下文中存在着这个方法的私有作用域，上层作用域的指向，方法的参数，这个作用域中定义的变量以及这个作用域的this对象。

## 事件循环机制
js特点：
- 单线程：代码在执行的时候，只有一个主线程
- 非阻塞：代码需要执行一项异步任务时，主线程会先挂起这个任务

事件触发线程所管理的那些任务就是从JS引擎线程上产生的，主线程在运行时，执行栈中的代码调用某些异步API（DOM、AJAX、setTimeout）时就会在任务队列中添加事件，执行栈中的代码执行完毕后，就会读取任务队列中的事件，如果有事件需要执行，将其添加到主线程的执行栈，去执行事件对应的回调函数，如此循环往复，形成事件循环机制。

js中有两种任务类型：微任务和宏任务。在ES6中，微任务称为jobs，宏任务称为task（宏任务并非全是异步任务）。
- 宏任务：主代码块、setTimeout、setInterval、setImmediate、I/O、UI rendering
- 微任务：process.nextTick、promise、Object.observe、MutationObserver

浏览器为了能够使JS引擎线程和GUI渲染线程有序切换，会在当前宏任务结束之后，下一个宏任务开始之前，对页面进行重新渲染。

微任务会在**当前宏任务**执行结束之后立即执行（在宏任务执行之后，UI渲染执行之前执行的任务）。

流程：
1. 执行一个宏任务
2. 执行宏任务过程中如遇到微任务，就将其添加到微任务的任务队列之中
3. 宏任务执行完成之后，立即执行当前微任务队列中的所有任务
4. JS引擎线程挂起，GUI渲染线程执行
5. GUI渲染线程执行完毕后挂起，JS引擎线程开始下一个宏任务
